# --------------- #
# Active profiles #
# --------------- #
#   profiles are used to customise platform operations in following areas
#   - container orchestrator (options: env_docker-engine, env_docker-compose, env_kubernetes)
#   - dcn setup (options: dcn_ansible, dcn_manual, dcn_none)
#   - service configuration (options: conf_download, conf_repo)
#   - database (options: db_memory, db_standalone)
spring.profiles.active=env_kubernetes, dcn_manual, conf_repo, db_memory

# ---------------- #
# General settings #
# ---------------- #
portal.url=http://portal.nmaas.gn4.net
server.port=9000

# -------------------------------------------------------- #
# NMaaS application deployment and configuration processes #
# -------------------------------------------------------- #
nmaas.service.deployment.check.interval=10
nmaas.service.deployment.max.duration=30

nmaas.portal.domains.codename.pattern=[\\p{Alnum}_]{2,8}

# ------- #
# Logging #
# ------- #
logging.file=log/nmaas.log
logging.level.net.geant.nmaas=DEBUG
logging.level.net.geant.nmaas.portal.api.security=INFO
logging.level.org.springframework=DEBUG
logging.level.net.schmizz.sshj=ERROR

# ----------------------------- #
# Kubernetes cluster properties #
# ----------------------------- #
# Flag indicating whether to use local chart tar.gz files (when set to true) rather than chart repositories
kubernetes.helm.charts.use.local.archives=true
# Flag indicating whether to use the default template for all deployments
kubernetes.namespace.use.default=true
# Kubernetes namespace for NMaaS deployments
kubernetes.namespace.default=default
# Kubernetes persistence storage class to be used by PVCs
kubernetes.persistence.class=managed-nfs-storage
# Name of ingress controller helm chart
kubernetes.ingress.chart=nginx-ingress.tgz

# -------------------------------------#
# GitLab configuration file repository #
# -------------------------------------#
# GitLab server IP address
gitlab.server=192.168.2.1
# Port on which GitLab API is exposed
gitlab.api.port=80
# Version of the GitLab API (by default v4)
gitlab.api.version=v4
# GitLab access token for root account
gitlab.api.token=testtoken
# Complete GitLab API URL
gitlab.api.url=http://${gitlab.server}:${gitlab.api.port}

# ----- #
# Other #
# ----- #
upload.dir=/tmp
jwt.tokenValidFor=3600000
jwt.refreshTokenValidFor=13600000
jwt.issuer=NMaaS
jwt.signingKey=testKey


#JOVANA
# ---------------------------------------------------------------------------------------- #
#                            --==== SSO configuration ====--                               #
#
# This enables SSO for nmaas-portal. The main concept is trusting an external auth source
# on the basis of a data exchange signed by a shared secret key.
#
# Flows are as follows :
#   - User goes to nmaas portal
#   - portal redirects user to sso url with return url in params
#   - sso does what is needed to authenticate user
#   - sso redirects user back to nmaas portal with userID (basically a signed, time limited
#     username)
#   - nmaas portal sends userID to nmaas sso login api endpoint
#   - api validates userID and create a bearer token using the given username
#
# This system allows to delegate current logged-in user name management to an external
# application with very loose coupling (http redirects and shared secret key) and still
# keep the user domains and privileges management in the nmaas application.
#
# For this to work you need to do the following :
#
# Add the "sso" entry in the portal json config :
# "sso": {
#   "name": "SSO service",
#   "loginUrl": "http://localhost/sp/login",
#   "logoutUrl": "http://localhost/sp/logout",
#   "allowsBasic": true
# }
#
# name : the text that will be display on the login button in the login page if you also
#   allow basic auth at the same time
#
# allowBasic : if set to true the user will be able to choose between local and sso auth
#   in the login page, if set to false the user will be redirected to the sso login url
#   immediately upon login page access
#
# loginUrl : url the user will be redirected to for login, at the end of the authentication
#   process the user must be sent back to the url given through the "return" query parameter
#   with a userID (see below)
#
# logoutUrl : url the user will be redirected to for logout, must do whatever is needed to
#   log the user out of the sso
#
# userID : transmitted through the "ssoUserId" query parameter, created by :
#   - building the timestamped username by concatenating the base 64 encoded username, a
#     pipe ("|") and the current unix timestamp (long)
#   - generating a signature of the timestamped username by computing a hmac sha256 signature
#     of it using the shared key
#   - concatenating the timestamped username, a pipe ("|") and the hex encoded signature
#   - this gives a string like :
#     YWRtaW4=|1521813856|8aa9e4382dfe57f21b9bf420f968f32abbd3d978d9e0adc5ed548b6e04b10425
# ---------------------------------------------------------------------------------------- #

# Shared userID signing key
sso.key=jovana_shared_secret_key

# Maximum age of userID (based on signed timestamp) after which they will be rejected
sso.timeout=1015
